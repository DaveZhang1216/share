何为C语言入门：
	内存在心中
C语言高级：
	汇编在心中
mov dst  src

微结构： 第一层（微指令）
指令集体系结构：第二层  每条指令可分解为多条微指令

操作系统 ：第三层 

汇编语言：第四层  需要操作系统翻译为指令集体系结构
高级语言：  翻译为汇编

补码：加法使用加法器实现  补码使减法变为加法
	补码 = 256-原 = 原求反+1
	
证明：补码的补码为原
	256-（256-原） = 原  补码可逆
	使用求反+1 避免了使用256 轮训数
         补码实现 将减法转为+法：
	a-b = a+(b补)  = a-b+ 轮回（进位不算）

	补码运算一般不会显式 汇编指令 而在汇编翻译为机器时用到
	负数 会用补码表示
	补码 

float: 12.25
IEEE编码： 二进制：1100.01
整数部分1100 小数01  小数点左移3位  1.10001
由于最高位必然1 舍去
正数所以符号位：0
指数位： 3+127 ：10000010  指数可能为负数 小于127为负数反之为正数
尾数位： 1000100....000（23位）

浮点数操作：
fild 将整数压入ST(0) 整数变为浮点数

bool:
真假 一字节

c++中只有变量存在内存地址
常量没有地址的
const 是伪常量

所谓的指针 *（p+1）根据给定p的指针类型判断步长x  然后【寄存器-init - nx】
c++
int nVar = 0x12345678;
int &b = nVar;
变量b 所在地址  存了nVar 的地址 
多了一个存放地址的空间  每一个函数需要引用它时会消耗2个赋值

使用引用传参：  编译器转为了指针 在函数内消耗与指针是一样的 但是变得安全了
	函数内部使用b 变量的位置 直接使用 寄存器寻址方式进行


NOT AND OR

操作模式：（操作系统级别   应用程序无需了解）
	保护模式：
		保护模式下所有与指令和特性都可用 程序赋予了独立的内存区域（段）
	虚拟8086模式：
		在保护模式下 执行实地址模式的软件
	实地址模式：
		实地址模式实现了程序设计环境以及其他的新特性，
		可切换到其他两种模式
		所有intel处理器都是实地址模式引导并切换其他模式
	系统管理模式
保护模式：
	有4G寻址 
实地址模式：
	最多1MB  处理器只能运行一个程序 可随时中断 允许读取修改RAM任何区域
	段+偏移就可以16位*4
EAX EBX ECX EDX  EFLAGS EIP
特殊用途：
	EAX:乘除自动使用
	ECX：循环计数器
	ESP：堆栈指针寄存器
	ESI,EDI: 内存数据告诉传送
	EBP： 高级语言引用函数参数与局部变量
段寄存器
指令指针EIP 下一条指令
EFLAGS

浮点单元ST(0) - ST(7)



逆向之Ollydbg:
f2: 断点设置
f3: 加载可执行程序
f4：程序执行到光标处
f5: 缩小、还原当前窗口
f7: 单步步入
f8：单步步过
f9：运行
Ctrl+f2 重新运行程序到起始处
Ctrl+f9: 执行到ret
Alt+F9: 执行到用户代码
Ctrl+G 输入16进制地址，在反汇编或数据窗口中快速定位到该地址处



反汇编原理：
开源反汇编引擎：proview  机器码转换工作
   通过解析指令操作码找到对应解析方式，将机器码重组为汇编代码
	

	



	
	
	
	






int nVar = 0x12345678;
010018F2  mov         dword ptr [nVar],12345678h   //4字节nVar = 12345678h
	int *pnVar = &nVar;
010018F9  lea         eax,[nVar]                                    //eax = &nVar
010018FC  mov         dword ptr [pnVar],eax              //4字节 pnVar = eax

0100190B  mov         eax,dword ptr [pnVar]   //取出 pnVar 中保存的4字节数据
0100190E  mov         ecx,dword ptr [eax]       //ecx = *pnVar





